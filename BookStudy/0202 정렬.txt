기본적인 정렬 알고리즘을 살펴보겠습니다.

1) SELECTION SORT
  a. 정렬할 5개의 데이터가 있다면 그중에서 가장 큰 값을 찾는다.
  b. 가장 큰 그 값을 맨 마지막과 자리를 바꾼다. --> 가장 큰값이 맨 끝자리로 가게됨, 그럼 맨 마지막애는 제자리르 찾은거임
  c. 같은일을 나머지 데이터에게 반복해 주면 됨
    --> 시간복잡도 O(n^2)


2) Bubble Sort
  a. 역시 제일 큰값을 찾아 제일 뒷자리로 옮김
  b. 다만 최대값을 찾아서 최대값을 맨 마지막으로 옮기는 방법이 조금 다름
  c. 0번째 index애부터 뒷자리 애랑 비교해서 큰거를 오른쪽으로 계속 자리를 바꾸는 방식


3) Insertion Sort 
  삽입할 때 뒤에서부터 넣는것이 효율적이다  
  역시 O(N^2) (Worst Case)
  a. 뒤에 하나씩 추가해서 걔를 비교해가며 위치를 찾는 정렬법
  b. 시작은 원소의 개수가 하나인 것에서 출발함  

--------------------------
Merge, quick, Heap 얘네가 주로 쓰이는 빠른 정렬 알고리즘임
이중에 Mergs와 Quick sort는 Divide and Conquer라는 방식을 사용한다.

* 먼저 분할 정복이란,
> 분할 : 해결하고자 하는 문제를 작은 크기의 ***동일한*** 문제들로 분할
> 정복 : 각각의 작은 문제를 __*순환적으로*__ 해결
> 합병 : 작은 각각의 문제의 해를 합하여(Merge) 원래 문제에 대한 해를 구함

분할에서 동일한 작은 문제로 나누기 때문에, 나눈 부분에서 새로운 알고리즘을 고안할 필요가 없이 recursive하게 작은 문제들을 해결해서 큰 문제를 해결하겠다는 것임.

4) Merge Sort
배열의 전체를 반으로 쪼개서, 앞쪽에서 최대값을 찾고 뒤에서도 최대값을 찾아서 둘 중에 최대값을 찾으면 그게 최대값이다 라는 논리.

길이가 1인 리스트는 그 자체가 정렬되어 있는 상태임.
결국 Merge할 때 정렬하는 직접적인 과정이 수행되는 것인데 이 부분을 구현하는 것이 포인트.






두개의 정렬된 List를 하나의 정렬된 List로 만들어 주는 단계가 Merge Sort에서 실제로 Sorting이 일어나는 과정임.
길이가 n/2인 두개의 list를 하나의 list로 합칠 방법을 생각해 보려면
추가배열을 만들어서 합병을 해줘야 하는 것임

중요) 2개의 list가 이미 정렬이 되어있는 상태라는 것임.
전체 10개의 값중에서 가장 작은 값은 두 두 리스트에서 맨 앞에 2개 중 하나임(당연한 얘기ㅎ)

3개의 index를 씀 (i, j, k) 


전체 배열을 A라고 하면
A[i]와 A[j]를 비교해서 더 작은 값이 k로 내려오면 되는것



Merge Sort는 recursion을 사용하기 때문에 매개변수를 명시적으로 적어주는게 좋음
function mergeSort(arr, p, r) // index p부터 index r 까지를 정렬한단 뜻으로
그럼 base case는 if(p<r) 로 하면 되겠지, p >= r이면 원소가 1개이거나 0개이단 뜻이니까 정렬이 이미 되어있다고 보면 됨.

먼저 데이터를 반으로 쪼개야함
```
if(p < r) {
  let q = Math.floor((p+r) /2)    // 중간지점을 찾는 것
  mergeSort(arr, p, q)    // 전반부 정렬
  mergeSort(arr, q+1, r)  // 후반부 정렬
  merge(A,p,q,r)      // 합병
}


// merge는 배열 arr의 p에서 q까지가 정렬된 list이고, q+1에서 r까지가 하나의 정렬된 list일 때 그 둘을 합쳐서 하나의 정렬된 list로 합치는 함수
function merge(arr, p, q, r){


}

```

머지소트는 재귀라 시간복잡도를 계산하긴 좀 어려움
그냥 O(nlogn)이라고 알고만 있어라





----------------------------------------------

분할정복을 사용하는 quick sort